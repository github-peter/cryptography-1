#ifndef AES_h
#define AES_h

#include "Byte.h"
#include "ByteSequence.h"
#include "ByteVector.h"
#include "PRP.h"

#include <stdexcept>

/// 128-bit AES PRP.
/// From FIPS 197: http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf
class AES: public PRP
{
   public:
      /// @param Key A key sequence with 16 bytes.
      AES(ByteSequence Key)
         :key(Key),k(Key.ToByteVector())
      {
         if( 16 != Key.Size() )
         {
            throw std::invalid_argument(
                  "AES: Key sequence not with 16 bytes");
         }
         expand_key(k);
      }
      /// @param in A cipher sequence with 16 bytes.
      /// @result A sequence with 16 bytes.
      ByteSequence Decrypt(const ByteSequence& in) const
      {
         if( 16 != in.Size() )
         {
            throw std::invalid_argument(
                  "AES::Decrypt: Cipher sequence not with 16 bytes");
         }
         ByteVector state(in.ToByteVector());

         AddRoundKey(state, &k[10*16] );
         for( int round = 9; round > 0; --round)
         {
            InvShiftRows(state);
            InvSubBytes(state);
            AddRoundKey(state, &k[round*16]);
            InvMixColumns(state);
         }
         InvShiftRows(state);
         InvSubBytes(state);
         AddRoundKey(state, &k[0]);
         return ByteSequence(state);
      }
      /// @param in A plaintext sequence with 16 bytes.
      /// @result A sequence with 16 bytes.
      ByteSequence Encrypt(const ByteSequence& in) const
      {
         if( 16 != in.Size() )
         {
            throw std::invalid_argument(
                  "AES::Encrypt: Plaintext sequence not with 16 bytes");
         }
         ByteVector state(in.ToByteVector());

         AddRoundKey(state, &k[0]);
         for( int round = 1; round < 10; ++round)
         {
            SubBytes(state);
            ShiftRows(state);
            MixColumns(state);
            AddRoundKey(state, &k[round*16]);
         }
         SubBytes(state);
         ShiftRows(state);
         AddRoundKey(state, &k[10*16] );

         return ByteSequence(state);
      }
      ByteVector::size_type GetBlockSize() const
      {
         return 16;
      }
   private:
      /// The 16 byte (128 bit) key.
      ByteSequence key;
      /// The 16 byte key, expanded during construction to 176 bytes using
      /// Rijndael's key schedule.
      ByteVector k;
      /// Used in Rijndael's key schedule
      static const ByteVector rcon;
      /// Inverse S boxes
      static const ByteVector inv_s;
      /// S boxes
      static const ByteVector s;
      /// @param state A column-wise 4x4 byte matrix.
      /// @param k An array with a key (from the expanded cipher key). Must be
      /// at least as long as the state vector.
      static void AddRoundKey(ByteVector& state,const Byte* k)
      {
         for(ByteVector::size_type N(state.size()),i(0); i <N; ++i)
         {
            state[i] ^= k[i];
         }
      }
      /// @param state A column-wise 4x4 byte matrix.
      static void MixColumns(ByteVector& state)
      {
         gmix_column(&state[0]);
         gmix_column(&state[4]);
         gmix_column(&state[8]);
         gmix_column(&state[12]);
      }
      /// @param state A column-wise 4x4 byte matrix.
      static void InvMixColumns(ByteVector& state)
      {
         inv_mix_column(&state[0]);
         inv_mix_column(&state[4]);
         inv_mix_column(&state[8]);
         inv_mix_column(&state[12]);
      }
      /// @param state A column-wise 4x4 byte matrix.
      static void ShiftRows(ByteVector& state)
      {
         ByteVector next_state(state.size());
         next_state[0] = state[0];
         next_state[1] = state[5];
         next_state[2] = state[10];
         next_state[3] = state[15];
         next_state[4] = state[4];
         next_state[5] = state[9];
         next_state[6] = state[14];
         next_state[7] = state[3];
         next_state[8] = state[8];
         next_state[9] = state[13];
         next_state[10] = state[2];
         next_state[11] = state[7];
         next_state[12] = state[12];
         next_state[13] = state[1];
         next_state[14] = state[6];
         next_state[15] = state[11];
         state = next_state;
      }
      /// @param state A column-wise 4x4 byte matrix.
      static void InvShiftRows(ByteVector& state)
      {
         ByteVector next_state(state.size());
         next_state[0] = state[0];
         next_state[1] = state[13];
         next_state[2] = state[10];
         next_state[3] = state[7];
         next_state[4] = state[4];
         next_state[5] = state[1];
         next_state[6] = state[14];
         next_state[7] = state[11];
         next_state[8] = state[8];
         next_state[9] = state[5];
         next_state[10] = state[2];
         next_state[11] = state[15];
         next_state[12] = state[12];
         next_state[13] = state[9];
         next_state[14] = state[6];
         next_state[15] = state[3];
         state = next_state;
      }
      /// @param state A column-wise 4x4 byte matrix.
      static void SubBytes(ByteVector& state)
      {
         ByteVector next_state(state.size());
         for( ByteVector::size_type N(state.size()), i(0); i < N; ++i )
         {
            next_state[i] = s[state[i]];
         }
         state = next_state;
      }
      /// @param state A column-wise 4x4 byte matrix.
      static void InvSubBytes(ByteVector& state)
      {
         ByteVector next_state(state.size());
         for( ByteVector::size_type N(state.size()), i(0); i < N; ++i )
         {
            next_state[i] = inv_s[state[i]];
         }
         state = next_state;
      }
      /// Expand the key, stored in the first 16 bytes of in, into 176 bytes
      /// using Rijndael's key expansion.
      static void expand_key(ByteVector& in)
      {
         if( 16 != in.size() )
         {
            throw std::invalid_argument(
                  "AES::expand_key: Key vector not with 16 bytes");
         }

         in.resize(176);

         Byte t[4];
         /* c is 16 because the first sub-key is the user-supplied key */
         Byte c = 16;
         Byte i = 1;
         Byte a;

         /* We need 11 sets of sixteen bytes each for 128-bit mode */
         while(c < 176) {
            /* Copy the temporary variable over from the last 4-byte
             * block */
            for(a = 0; a < 4; a++) 
               t[a] = in[a + c - 4];
            /* Every four blocks (of four bytes),
             * do a complex calculation */
            if(c % 16 == 0) {
               schedule_core(t,i);
               i++;
            }
            for(a = 0; a < 4; a++) {
               in[c] = in[c - 16] ^ t[a];
               c++;
            }
         }
      }
      static void gmix_column(Byte *r)
      {
         Byte a[4];
         Byte b[4];
         Byte c;
         Byte h;
         for(c=0;c<4;c++) {
            a[c] = r[c];
            h = r[c] & 0x80; /* hi bit */
            b[c] = r[c] << 1;
            if(h == 0x80)
               b[c] ^= 0x1b; /* Rijndael's Galois field */
         }
         r[0] = b[0] ^ a[3] ^ a[2] ^ b[1] ^ a[1];
         r[1] = b[1] ^ a[0] ^ a[3] ^ b[2] ^ a[2];
         r[2] = b[2] ^ a[1] ^ a[0] ^ b[3] ^ a[3];
         r[3] = b[3] ^ a[2] ^ a[1] ^ b[0] ^ a[0];
      }
      static Byte gmul(Byte a, Byte b)
      {
         Byte p = 0;
         Byte counter;
         Byte hi_bit_set;
         for(counter = 0; counter < 8; counter++) {
            if((b & 1) == 1)
               p ^= a;
            hi_bit_set = (a & 0x80);
            a <<= 1;
            if(hi_bit_set == 0x80) 
               a ^= 0x1b;		
            b >>= 1;
         }
         return p;
      }
      static void inv_mix_column(Byte *r)
      {
         Byte a[4];
         Byte c;
         for(c=0;c<4;c++) {
            a[c] = r[c];
         }
         r[0] = gmul(a[0],14) ^ gmul(a[3],9) ^ gmul(a[2],13) ^ gmul(a[1],11);
         r[1] = gmul(a[1],14) ^ gmul(a[0],9) ^ gmul(a[3],13) ^ gmul(a[2],11);
         r[2] = gmul(a[2],14) ^ gmul(a[1],9) ^ gmul(a[0],13) ^ gmul(a[3],11);
         r[3] = gmul(a[3],14) ^ gmul(a[2],9) ^ gmul(a[1],13) ^ gmul(a[0],11);
      }
      /// Rotate the input 8 bits to the left.
      static void rotate(Byte* in)
      {
         Byte a,c;
         a = in[0];
         for(c=0;c<3;c++) 
            in[c] = in[c + 1];
         in[3] = a;
         return;
      }
      /// The core of Rijndael's key expansion.
      static void schedule_core(Byte* in,Byte i)
      {
         Byte a;
         rotate(in);
         /* Apply Rijndael's s-box on all 4 bytes */
         for(a = 0; a < 4; a++) 
            in[a] = s[in[a]];
         /* On just the first byte,add 2^i to the byte */
         in[0] ^= rcon[i];
      }
};
const ByteVector AES::inv_s =
{
   0x52,0x09,0x6A,0xD5,0x30,0x36,0xA5,0x38,0xBF,0x40,0xA3,0x9E,0x81,0xF3,0xD7,0xFB,
   0x7C,0xE3,0x39,0x82,0x9B,0x2F,0xFF,0x87,0x34,0x8E,0x43,0x44,0xC4,0xDE,0xE9,0xCB,
   0x54,0x7B,0x94,0x32,0xA6,0xC2,0x23,0x3D,0xEE,0x4C,0x95,0x0B,0x42,0xFA,0xC3,0x4E,
   0x08,0x2E,0xA1,0x66,0x28,0xD9,0x24,0xB2,0x76,0x5B,0xA2,0x49,0x6D,0x8B,0xD1,0x25,
   0x72,0xF8,0xF6,0x64,0x86,0x68,0x98,0x16,0xD4,0xA4,0x5C,0xCC,0x5D,0x65,0xB6,0x92,
   0x6C,0x70,0x48,0x50,0xFD,0xED,0xB9,0xDA,0x5E,0x15,0x46,0x57,0xA7,0x8D,0x9D,0x84,
   0x90,0xD8,0xAB,0x00,0x8C,0xBC,0xD3,0x0A,0xF7,0xE4,0x58,0x05,0xB8,0xB3,0x45,0x06,
   0xD0,0x2C,0x1E,0x8F,0xCA,0x3F,0x0F,0x02,0xC1,0xAF,0xBD,0x03,0x01,0x13,0x8A,0x6B,
   0x3A,0x91,0x11,0x41,0x4F,0x67,0xDC,0xEA,0x97,0xF2,0xCF,0xCE,0xF0,0xB4,0xE6,0x73,
   0x96,0xAC,0x74,0x22,0xE7,0xAD,0x35,0x85,0xE2,0xF9,0x37,0xE8,0x1C,0x75,0xDF,0x6E,
   0x47,0xF1,0x1A,0x71,0x1D,0x29,0xC5,0x89,0x6F,0xB7,0x62,0x0E,0xAA,0x18,0xBE,0x1B,
   0xFC,0x56,0x3E,0x4B,0xC6,0xD2,0x79,0x20,0x9A,0xDB,0xC0,0xFE,0x78,0xCD,0x5A,0xF4,
   0x1F,0xDD,0xA8,0x33,0x88,0x07,0xC7,0x31,0xB1,0x12,0x10,0x59,0x27,0x80,0xEC,0x5F,
   0x60,0x51,0x7F,0xA9,0x19,0xB5,0x4A,0x0D,0x2D,0xE5,0x7A,0x9F,0x93,0xC9,0x9C,0xEF,
   0xA0,0xE0,0x3B,0x4D,0xAE,0x2A,0xF5,0xB0,0xC8,0xEB,0xBB,0x3C,0x83,0x53,0x99,0x61,
   0x17,0x2B,0x04,0x7E,0xBA,0x77,0xD6,0x26,0xE1,0x69,0x14,0x63,0x55,0x21,0x0C,0x7D
};
const ByteVector AES::rcon =
{
   0x8d,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36,0x6c,0xd8,0xab,0x4d,0x9a,
   0x2f,0x5e,0xbc,0x63,0xc6,0x97,0x35,0x6a,0xd4,0xb3,0x7d,0xfa,0xef,0xc5,0x91,0x39,
   0x72,0xe4,0xd3,0xbd,0x61,0xc2,0x9f,0x25,0x4a,0x94,0x33,0x66,0xcc,0x83,0x1d,0x3a,
   0x74,0xe8,0xcb,0x8d,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36,0x6c,0xd8,
   0xab,0x4d,0x9a,0x2f,0x5e,0xbc,0x63,0xc6,0x97,0x35,0x6a,0xd4,0xb3,0x7d,0xfa,0xef,
   0xc5,0x91,0x39,0x72,0xe4,0xd3,0xbd,0x61,0xc2,0x9f,0x25,0x4a,0x94,0x33,0x66,0xcc,
   0x83,0x1d,0x3a,0x74,0xe8,0xcb,0x8d,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,
   0x36,0x6c,0xd8,0xab,0x4d,0x9a,0x2f,0x5e,0xbc,0x63,0xc6,0x97,0x35,0x6a,0xd4,0xb3,
   0x7d,0xfa,0xef,0xc5,0x91,0x39,0x72,0xe4,0xd3,0xbd,0x61,0xc2,0x9f,0x25,0x4a,0x94,
   0x33,0x66,0xcc,0x83,0x1d,0x3a,0x74,0xe8,0xcb,0x8d,0x01,0x02,0x04,0x08,0x10,0x20,
   0x40,0x80,0x1b,0x36,0x6c,0xd8,0xab,0x4d,0x9a,0x2f,0x5e,0xbc,0x63,0xc6,0x97,0x35,
   0x6a,0xd4,0xb3,0x7d,0xfa,0xef,0xc5,0x91,0x39,0x72,0xe4,0xd3,0xbd,0x61,0xc2,0x9f,
   0x25,0x4a,0x94,0x33,0x66,0xcc,0x83,0x1d,0x3a,0x74,0xe8,0xcb,0x8d,0x01,0x02,0x04,
   0x08,0x10,0x20,0x40,0x80,0x1b,0x36,0x6c,0xd8,0xab,0x4d,0x9a,0x2f,0x5e,0xbc,0x63,
   0xc6,0x97,0x35,0x6a,0xd4,0xb3,0x7d,0xfa,0xef,0xc5,0x91,0x39,0x72,0xe4,0xd3,0xbd,
   0x61,0xc2,0x9f,0x25,0x4a,0x94,0x33,0x66,0xcc,0x83,0x1d,0x3a,0x74,0xe8,0xcb,0x8d
};
const ByteVector AES::s =
{
   0x63,0x7C,0x77,0x7B,0xF2,0x6B,0x6F,0xC5,0x30,0x01,0x67,0x2B,0xFE,0xD7,0xAB,0x76,
   0xCA,0x82,0xC9,0x7D,0xFA,0x59,0x47,0xF0,0xAD,0xD4,0xA2,0xAF,0x9C,0xA4,0x72,0xC0,
   0xB7,0xFD,0x93,0x26,0x36,0x3F,0xF7,0xCC,0x34,0xA5,0xE5,0xF1,0x71,0xD8,0x31,0x15,
   0x04,0xC7,0x23,0xC3,0x18,0x96,0x05,0x9A,0x07,0x12,0x80,0xE2,0xEB,0x27,0xB2,0x75,
   0x09,0x83,0x2C,0x1A,0x1B,0x6E,0x5A,0xA0,0x52,0x3B,0xD6,0xB3,0x29,0xE3,0x2F,0x84,
   0x53,0xD1,0x00,0xED,0x20,0xFC,0xB1,0x5B,0x6A,0xCB,0xBE,0x39,0x4A,0x4C,0x58,0xCF,
   0xD0,0xEF,0xAA,0xFB,0x43,0x4D,0x33,0x85,0x45,0xF9,0x02,0x7F,0x50,0x3C,0x9F,0xA8,
   0x51,0xA3,0x40,0x8F,0x92,0x9D,0x38,0xF5,0xBC,0xB6,0xDA,0x21,0x10,0xFF,0xF3,0xD2,
   0xCD,0x0C,0x13,0xEC,0x5F,0x97,0x44,0x17,0xC4,0xA7,0x7E,0x3D,0x64,0x5D,0x19,0x73,
   0x60,0x81,0x4F,0xDC,0x22,0x2A,0x90,0x88,0x46,0xEE,0xB8,0x14,0xDE,0x5E,0x0B,0xDB,
   0xE0,0x32,0x3A,0x0A,0x49,0x06,0x24,0x5C,0xC2,0xD3,0xAC,0x62,0x91,0x95,0xE4,0x79,
   0xE7,0xC8,0x37,0x6D,0x8D,0xD5,0x4E,0xA9,0x6C,0x56,0xF4,0xEA,0x65,0x7A,0xAE,0x08,
   0xBA,0x78,0x25,0x2E,0x1C,0xA6,0xB4,0xC6,0xE8,0xDD,0x74,0x1F,0x4B,0xBD,0x8B,0x8A,
   0x70,0x3E,0xB5,0x66,0x48,0x03,0xF6,0x0E,0x61,0x35,0x57,0xB9,0x86,0xC1,0x1D,0x9E,
   0xE1,0xF8,0x98,0x11,0x69,0xD9,0x8E,0x94,0x9B,0x1E,0x87,0xE9,0xCE,0x55,0x28,0xDF,
   0x8C,0xA1,0x89,0x0D,0xBF,0xE6,0x42,0x68,0x41,0x99,0x2D,0x0F,0xB0,0x54,0xBB,0x16
};
#endif
